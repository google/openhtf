# Copyright 2016 Google Inc. All Rights Reserved.

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


"""Read in a .xls file and generate a units module for OpenHTF.

UNECE, the United Nations Economic Commision for Europe, publishes a set of
unit codes for international trade in the form of Excel spreadsheets (.xls
files). Various revisions of the spreadsheet can be found as part of the the
downloadable "Codes for Units of Measurement used in the International Trade"
.zip archive listed here:

http://www.unece.org/cefact/codesfortrade/codes_index.html

This tool is used to parse those spreadsheets and turn the published standard
code set into a sub-module inside OpenHTF.

Typical usage of this generation script looks like:

python ./bin/units_from_xls.py --infile ~/rec20_Rev9e_2014.xls \
--outfile ./__init__.py

Legal python names are generated for the UnitInfo objects from the "Name" field
on the spreadsheet, generally by removing special characters, turning spaces
into underscores, and coverting to uppercase.
"""


import argparse
import os
import shutil
import re
import sys
from tempfile import mkstemp

import xlrd


# Column names for the columns we care about. This list must be populated in
# the expected order: [<name label>, <code label>, <suffix label>].
COLUMN_NAMES = ['Name',
                'Common\nCode',
                'Symbol']

PRE = '''# coding: iso-8859-1
# THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.

# Copyright 2016 Google Inc. All Rights Reserved.

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


"""Units of measure for OpenHTF.

Used to retrieve UNECE unit codes by object, name, or suffix:

    from openhtf.util import units

    # The following three lines are equivalent:
    @measures(units.METRE_PER_SECOND)
    @measures(units.Unit('m/s'))
    @measures(units.Unit('metre per second'))

OpenHTF uses UNECE unit codes internally because they are relatively complete
and modern, and because they are recognized internationally. For full details
regarding where we get the codes from and which units are avaiable, see the
docstring at the top of openhtf/util/units/bin/units_from_xls.py.
"""


import collections


UnitInfo = collections.namedtuple('Unit', 'name code suffix')

ALL_UNITS = []


# NO_DIMENSION means that there are units set, but they cannot be expressed
# by a known dimension (such as a ratio)
NO_DIMENSION = UnitInfo('No dimension', 'NDL', None)
ALL_UNITS.append(NO_DIMENSION)

NONE = UnitInfo('None', None, None)
ALL_UNITS.append(NONE)
'''

POST = '''
# Convenience aliases.
MINUTE = MINUTE_UNIT_OF_TIME
ALL_UNITS.append(MINUTE)

SECOND = SECOND_UNIT_OF_TIME
ALL_UNITS.append(SECOND)


class UnitLookup(object):
  """Facilitates user-friendly access to units."""
  def __init__(self, lookup):
    self.lookup = lookup

  def __call__(self, description_or_suffix):
    """Provides instantiation-like access for units module."""
    return self.lookup[description_or_suffix]


UNITS_BY_NAME = {u.name: u for u in ALL_UNITS}
UNITS_BY_SUFFIX = {u.suffix: u for u in ALL_UNITS}
UNITS_BY_ALL = {}
UNITS_BY_ALL.update(UNITS_BY_NAME)
UNITS_BY_ALL.update(UNITS_BY_SUFFIX)

Unit = UnitLookup(UNITS_BY_ALL)
'''

SHEET_NAME = 'Annex II & Annex III'
UNIT_KEY_REPLACEMENTS = {' ': '_',
                         ',' : '_',
                         '.': '_',
                         '-': '_',
                         '/': '_PER_',
                         '%': 'PERCENT',
                         '[': '',
                         ']': '',
                         '(': '',
                         ')': '',
                         "'": '',
                         '8':  'EIGHT',
                         '15': 'FIFTEEN',
                         '30': 'THIRTY',
                         '\\': '_',
                         unichr(160): '_',
                         unichr(176): 'DEG_',
                         unichr(186): 'DEG_',
                         unichr(8211): '_',
                        }


def main():
  """Main entry point for UNECE code .xls parsing."""
  parser = argparse.ArgumentParser(description='Units From XLS',
                                   prog='python units_from_xls.py')
  parser.add_argument('--infile', type=str,
                      help='A .xls file to parse.')
  parser.add_argument('--outfile', type=str, default='__init__.py',
                      help='Where to put the generated .py file.')
  args = parser.parse_args()

  unit_defs = unit_defs_from_sheet(
      xlrd.open_workbook(args.infile).sheet_by_name(SHEET_NAME),
      COLUMN_NAMES)

  _, tmp_path = mkstemp()
  with open(tmp_path, 'w') as new_file:
    new_file.write(PRE)
    new_file.writelines(
        [line.encode('utf8', 'replace') for line in unit_defs])
    new_file.write(POST)
    new_file.flush()

  os.remove(args.outfile)
  shutil.move(tmp_path, args.outfile)


def unit_defs_from_sheet(sheet, column_names):
  """A generator that parses a worksheet containing UNECE code definitions.

  Args:
    sheet: An xldr.sheet object representing a UNECE code worksheet.
    column_names: A list/tuple with the expected column names corresponding to
                  the unit name, code and suffix in that order.
  Yields: Lines of Python source code that define OpenHTF Unit objects.
  """
  seen = set()
  try:
    col_indices = {}
    rows = sheet.get_rows()
    
    # Find the indices for the columns we care about.
    for idx, cell in enumerate(rows.next()):
      if cell.value in column_names:
        col_indices[cell.value] = idx

    # loop over all remaining rows and pull out units.
    for row in rows:
      name = row[col_indices[column_names[0]]].value.replace("'", r'\'')
      code = row[col_indices[column_names[1]]].value
      suffix = row[col_indices[column_names[2]]].value.replace("'", r'\'')
      key = unit_key_from_name(name, UNIT_KEY_REPLACEMENTS)
      if key in seen:
        continue
      seen.add(key)

      yield "%s = UnitInfo('%s', '%s', '''%s''')\n" % (key, name, code, suffix)
      yield "ALL_UNITS.append(%s)\n" % key

  except xlrd.XLRDError:
    sys.stdout.write('Unable to process the .xls file.')


def unit_key_from_name(name, replacements=None):
  """Return a legal python name for the given name for use as a unit key."""
  replacements = replacements or {}
  result = name[:]

  for old, new in replacements.iteritems():
    result = result.replace(old, new)

  # Collapse redundant underscores and convert to uppercase.
  result = re.sub(r'_+', '_', result.upper())

  return result


def insert_into_file(filepath, code, start, end):
  """Replace the contents of the file between the start and end markers.

  Args:
    file: A file-like object whose contents to modify.
    code: An iterable of lines of code to replace part of the file with.
    start: The contents of the line below which to replace text.
    end: The contents of the line after which to leave contents intact.
  """
  _, tmp_path = mkstemp()
  skipping = False

  with open(filepath) as old_file, open(tmp_path, 'w') as new_file:
    for old_line in old_file:
      if old_line.find(start) == 0:
        new_file.write(old_line)
        new_file.writelines(
            [line.encode('utf8', 'replace') for line in code])
        skipping = True
      elif old_line.find(end) == 0:
        new_file.write(old_line)
        skipping = False
      elif not skipping:
        new_file.write(old_line)
    new_file.flush()

    os.remove(filepath)
    shutil.move(tmp_path, filepath)


if __name__ == '__main__':
  main()
