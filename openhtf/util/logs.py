# Copyright 2014 Google Inc. All Rights Reserved.

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


"""Logging mechanisms for use in OpenHTF.

Test logs are primarily generated by test authors, and are included in test
record output.  The preferred way to do this is via the 'test' first parameter
passed to test phases:

  def MyLoggingPhase(test):
    test.logger.info('My log line')

In order to facilitate adding logs to the test record output from places
outside the test phase (without forcing the author to pass the logger object
around), a user can directly use a logger instance assocated with the Test's
output TestRecord.  This is accessible via the get_record_logger_for function
in this module, which take's a Test's UID and returns a Python Logger:

  import logging
  from openhtf.util import logs

  class MyHelperClass(object):
    def __init__(self)
      self.test_uid = ''

    def MyRandomMethod(self):
      logs.get_record_logger_for(self.test_uid).info(
          'Log this to currently running test.')

  def MyPhase(test, helper):
    helper.MyRandomMethod()

  if __name__ == '__main__':
    helper = MyHelperClass()
    my_test = openhtf.Test(MyPhase.with_args(helper=helper))
    helper.test_uid = my_test.uid
    my_test.Excute()

Framework logs are by default output only to stderr at a warning level.  They
can be additionally logged to a file (with a different level) via the
--log-file and --log-file-level flags.  The --quiet flag may be set to suppress
all framework log output to stderr.  The --verbosity flag may be used to set
the log level threshold for framework logs output to stderr.

Test record logs are by default output to stdout at a debug level.  Use the
--test-record-verbosity flag to select a different level of chatter.
"""

import argparse
import collections
import datetime
import logging
import os
import re
import sys
import textwrap
import traceback

from openhtf.util import argv
from openhtf.util import console_output
from openhtf.util import functions
import six


# The number of v's provided as command line arguments to control verbosity.
# Will be overridden if the ARG_PARSER below parses the -v argument.
CLI_LOGGING_VERBOSITY = 0

ARG_PARSER = argv.ModuleParser()
ARG_PARSER.add_argument(
    '-v', action=argv.StoreRepsInModule,
    target='%s.CLI_LOGGING_VERBOSITY' % __name__,
    help=textwrap.dedent('''\
        CLI logging verbosity. Can be repeated to increase verbosity (i.e. -v,
        -vv, -vvv).'''))

LOGGER_PREFIX = 'openhtf'
RECORD_LOGGER_PREFIX = '.'.join((LOGGER_PREFIX, 'test_record'))
RECORD_LOGGER_RE = re.compile(
    r'%s\.(?P<test_uid>[^.]*)\.?' % RECORD_LOGGER_PREFIX)
SUBSYSTEM_LOGGER_RE = re.compile(
    r'%s\.[^.]*\.(?P<subsys>plug|phase)\.(?P<id>[^.]*)' % RECORD_LOGGER_PREFIX)

_LOGONCE_SEEN = set()


LogRecord = collections.namedtuple(
    'LogRecord', 'level logger_name source lineno timestamp_millis message')


def get_record_logger_for(test_uid):
  return logging.getLogger('.'.join((RECORD_LOGGER_PREFIX, test_uid)))


def initialize_record_logger(test_uid, test_record, notify_update):
  htf_logger = logging.getLogger(LOGGER_PREFIX)
  # Avoid duplicate logging if other loggers are configured.
  htf_logger.propagate = False
  # Add the handler for this test record to the main OpenHTF logger.
  htf_logger.addHandler(RecordHandler(test_uid, test_record, notify_update))
  htf_logger.setLevel(logging.DEBUG)  # Log everything to the test record.
  # Also create a sub-logger specific to this test UID and return it.
  logger = get_record_logger_for(test_uid)
  # All record loggers have a shared parent that's separately configured, so
  # we want to propagate to that logger.
  logger.propagate = True
  return logger


def log_once(log_func, msg, *args, **kwargs):
  """"Logs a message only once."""
  if msg not in _LOGONCE_SEEN:
    log_func(msg, *args, **kwargs)
    # Only check the message since it's likely from the source code so lifespan
    # is long and no copies are made.
    _LOGONCE_SEEN.add(msg)


class MacAddressLogFilter(logging.Filter):
  """A filter which redacts mac addresses if it sees one."""

  MAC_REPLACE_RE = re.compile(r"""
        ((?:[\dA-F]{2}:){3})       # 3-part prefix, f8:8f:ca means google
        (?:[\dA-F]{2}(:|\b)){3}    # the remaining octets
        """, re.IGNORECASE | re.VERBOSE)
  MAC_REPLACEMENT = r'\1<REDACTED>'

  def __init__(self):
    super(MacAddressLogFilter, self).__init__()

  def filter(self, record):
    if self.MAC_REPLACE_RE.search(record.getMessage()):
      # Update all the things to have no mac address in them
      if isinstance(record.msg, six.string_types):
        record.msg = self.MAC_REPLACE_RE.sub(self.MAC_REPLACEMENT, record.msg)
        record.args = tuple([
            self.MAC_REPLACE_RE.sub(self.MAC_REPLACEMENT, str(arg))
            if isinstance(arg, six.string_types)
            else arg for arg in record.args])
      else:
        record.msg = self.MAC_REPLACE_RE.sub(
            self.MAC_REPLACEMENT, record.getMessage())
    return True

# We use one shared instance of this, it has no internal state.
MAC_FILTER = MacAddressLogFilter()


class TestUidFilter(logging.Filter):
  """Only allow logs to pass whose logger source matches the given uid."""
  def __init__(self, test_uid):
    super(TestUidFilter, self).__init__()
    self.test_uid = test_uid

  def filter(self, record):
    # Only filter logs that from individual test instances. Framework logs go
    # to every test instance's test record to make station debugging easier.
    match = RECORD_LOGGER_RE.match(record.name)
    return not match or (match.group('test_uid') == self.test_uid)


class RecordHandler(logging.Handler):
  """A handler to save logs to an HTF TestRecord."""

  def __init__(self, test_uid, test_record, notify_update):
    # Record handlers get the DEBUG logging level since we don't want any
    # information to be lost.
    super(RecordHandler, self).__init__(level=logging.DEBUG)
    self.test_uid = test_uid
    self._test_record = test_record
    self._notify_update = notify_update
    self.addFilter(MAC_FILTER)
    self.addFilter(TestUidFilter(test_uid))

  def emit(self, record):
    """Save a logging.LogRecord to our test record.

    LogRecords carry a significant amount of information with them including the
    logger name and level information.  This allows us to be a little clever
    about what we store so that filtering can occur on the client.

    Args:
      record: A logging.LogRecord to log.
    """
    message = record.getMessage()
    if record.exc_info:
      message += '\n' + ''.join(traceback.format_exception(
          *record.exc_info))

    log_record = LogRecord(
        record.levelno, record.name, os.path.basename(record.pathname),
        record.lineno, int(record.created * 1000), message
    )
    self._test_record.log_records.append(log_record)
    self._notify_update()


class CliFormatter(logging.Formatter):
  """Formats log messages for printing to the CLI."""
  def format(self, record):
    """Format the record as tersely as possible but preserve info."""
    super(CliFormatter, self).format(record)
    localized_time = datetime.datetime.fromtimestamp(record.created)
    terse_time = localized_time.strftime(u'%H:%M:%S')
    terse_level = record.levelname[0]
    terse_name = record.name.split('.')[-1]
    match = RECORD_LOGGER_RE.match(record.name)
    if match:
      # Figure out which OpenHTF subsystem the record came from.
      subsys_match = SUBSYSTEM_LOGGER_RE.match(record.name)
      if subsys_match:
        terse_name = '<{subsys}: {id}>'.format(
            subsys=subsys_match.group('subsys'),
            id=subsys_match.group('id'))
      else:
        # Fall back to using the last five characters of the test UUID.
        terse_name = '<test %s>' % match.group('test_uid')[-5:]
    return '{lvl} {time} {logger} - {msg}'.format(lvl=terse_level,
                                                  time=terse_time,
                                                  logger=terse_name,
                                                  msg=record.message)


@functions.call_once
def configure_cli_logging():
  """Configure OpenHTF to log to the CLI based on verbosity arg."""
  if CLI_LOGGING_VERBOSITY == 0:
    return # The default behavior is not to log anything to the CLI.
  logging_level = None
  if CLI_LOGGING_VERBOSITY == 1:
    logging_level = logging.INFO
  elif CLI_LOGGING_VERBOSITY == 2:
    logging_level = logging.DEBUG
  elif CLI_LOGGING_VERBOSITY > 2:
    logging_level = logging.NOTSET

  cli_handler = logging.StreamHandler(stream=sys.stdout)
  cli_handler.setFormatter(CliFormatter())
  cli_handler.setLevel(logging_level)
  cli_handler.addFilter(MAC_FILTER)
  # Make sure we also suppress CLI logging (in addition to anything that would
  # have been printed through the printing helper functions) if the user has set
  # the --quiet flag in the console_output module.
  cli_handler.addFilter(console_output.CliQuietFilter())
  htf_logger = logging.getLogger(LOGGER_PREFIX)
  htf_logger.addHandler(cli_handler)
  # We don't want duplicate logging if other loggers are configured.
  htf_logger.propagate = False
